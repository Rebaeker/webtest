<./database/initdb.js>
import sqlite from 'better-sqlite3';
import * as path from 'path';

const dbPath = path.resolve("./src/database", "database.db");
console.log(dbPath);

// Die Datei muss ausgeführt werden, um die Datenbank zu initialisieren 
// Dies erfolgt im Terminal mit npx node .\initdb.js
// Es wird gefragt ob Node installiert werden soll --> y eingeben. Dann sollte die Datei laufen. 
function initDb() {
  let db = new sqlite(dbPath , sqlite.OPEN_READWRITE, (err) => {
    if (err) {
        console.error(err.message);
    }
    verbose: console.log
  });

  // Mit Create Table wird die Tabelle angelegt, wenn diese noch nicht existiert. 
  // ACHTUNG: Wenn die Tabelle schon angelegt wurde, dann wird diese nicht mehr gelöscht. 
  //          Heißt, eine wiederholte Ausführung der Funktion ändert die Datenbank nicht. 
  //          Wenn die Tabelle mal angelegt ist, muss diese mit Alter Table erweitert werden.  

  //unique bei user name, da jeder nur einmal vergeben werden kann, bei mail auch, da jede mail nur für einen account registriert werden kann
  let resultUser = db.exec(`CREATE TABLE IF NOT EXISTS Users ( 
    'id' TEXT NOT NULL PRIMARY KEY, 
    'prename' TEXT NOT NULL DEFAULT '', 
    'surname' TEXT NOT NULL DEFAULT '', 
    'username' TEXT NOT NULL UNIQUE,
    'password' TEXT NOT NULL, 
    'phone' TEXT, 
    'email' TEXT NOT NULL UNIQUE,
    'createdAt' INT NOT NULL DEFAULT 0, 
    'updatedAt' INT NOT NULL DEFAULT 0)`);
    console.log(resultUser);
    //  Hier wird ie Neue Column username hinzugefügt. 
  //  let addPerson = db.exec("ALTER TABLE Persons ADD COLUMN username TEXT NOT NULL DEFAULT ''");
  //  console.log(addPerson);

  /*let resultItem = db.exec(`CREATE TABLE IF NOT EXISTS Items ( 
      'id' TEXT NOT NULL PRIMARY KEY, 
      'name' TEXT NOT NULL DEFAULT '', 
      'description' TEXT NOT NULL DEFAULT '', 
      'serial' TEXT NOT NULL DEFAULT '', 
      'img' TEXT NOT NULL DEFAULT '', 
      'createdAt' INT NOT NULL DEFAULT 0, 
      'updatedAt' INT NOT NULL DEFAULT 0)`);
  console.log(resultItem);*/
  
  let resultCategory = db.exec(`CREATE TABLE IF NOT EXISTS categories ( 
    'id' TEXT NOT NULL PRIMARY KEY, 
    'name' TEXT NOT NULL UNIQUE, 
    'createdAt' INT NOT NULL DEFAULT 0, 
    'updatedAt' INT NOT NULL DEFAULT 0)`);
  console.log(resultCategory);

  const defaultCategories = ['Schlüssel', 'Elektronik', 'Kleidung', 'Dokumente', 'Schmuck', 'Sonstiges'];
  defaultCategories.forEach((cat) => {
    db.prepare(`
      INSERT OR IGNORE INTO Categories (id, name, createdAt, updatedAt)
      VALUES (lower(hex(randomblob(16))), ?, strftime('%s','now'), strftime('%s','now'))
    `).run(cat);
  });

//  Hier wird ie Neue Column password hinzugefügt. 
   // let addPerson = db.exec("ALTER TABLE Persons ADD COLUMN password TEXT NOT NULL DEFAULT ''");
   // console.log(addPerson);
//  Hier wird ie Neue Column admin hinzugefügt. 
   /*let addPerson = db.exec("ALTER TABLE Persons ADD COLUMN admin INT NOT NULL DEFAULT 0");
   console.log(addPerson);*/


  // --- LOCATIONS ---

  // Tabelle für Locations erstellen/ Die 'id' ist der Primärschlüssel, 'name' muss vorhanden sein
  let resultLocations = db.exec(`
  CREATE TABLE IF NOT EXISTS Locations (
    'id' TEXT NOT NULL PRIMARY KEY,
    'name' TEXT NOT NULL,
    'createdAt' INTEGER NOT NULL DEFAULT 0,
    'updatedAt' INTEGER NOT NULL DEFAULT 0)`);
  console.log("Locations Table Result:", resultLocations);
  const defaultLocations = ['Bibliothek', 'Mensa', 'Hauptgebäude', 'Sportzentrum', 'Parkplatz', 'Sonstiges'];
  defaultLocations.forEach((loc) => {
    db.prepare(`
      INSERT OR IGNORE INTO Locations (id, name, createdAt, updatedAt)
      VALUES (lower(hex(randomblob(16))), ?, strftime('%s','now'), strftime('%s','now'))
    `).run(loc);
  });

// --- ITEMS ---
let resultItems = db.exec(`
    CREATE TABLE IF NOT EXISTS Items (
      'id' TEXT NOT NULL PRIMARY KEY,
      'name' TEXT NOT NULL,
      'img' TEXT, -- Optionaler Bildpfad
      'type' TEXT NOT NULL, -- 'isLost' oder 'isFound'
      'title' TEXT NOT NULL,
      'date' INTEGER,        -- Wann gefunden/verloren (Unix Timestamp, optional)
      'reportedAt' INTEGER NOT NULL, -- Wann gemeldet (Unix Timestamp)
      'categoryId' TEXT, -- Fremdschlüssel zu Categories
      'description' TEXT, -- Optional
      'locationId' TEXT, -- Fremdschlüssel zu Locations
      'userId' TEXT,     -- Fremdschlüssel zu Users
      'createdAt' INTEGER NOT NULL DEFAULT 0,
      'updatedAt' INTEGER NOT NULL DEFAULT 0,
      FOREIGN KEY ('categoryId') REFERENCES Categories('id'),
      FOREIGN KEY ('locationId') REFERENCES Locations('id'),
      FOREIGN KEY ('userId') REFERENCES Users('id')
    );
  `);
  console.log("Items Table Result:", resultItems);

  db.close();
}

initDb();
</./database/initdb.js>
<./components/itemCard.astro>
---
// src/components/ItemCard.astro

// Defines the props that the component expects to receive.
export interface Props {
  id: string;
  title: string;
  status: 'lost' | 'found';
  // VERBESSERUNG: category und location sind jetzt optional, falls sie nicht als Name vorliegen.
  category?: string;
  location?: string;
  date: string;
}

const { id, title, status, category, location, date } = Astro.props;

// Determines the CSS classes for the card's background and border based on the status.
const cardClasses = 
  status === 'lost' 
    ? 'bg-red-50 border-red-200' 
    : 'bg-green-50 border-green-200';

// Determines the CSS classes for the status badge.
const badgeClasses = 
  status === 'lost'
    ? 'bg-red-100 text-red-800'
    : 'bg-green-100 text-green-800';
---

<div class={`p-4 rounded-lg shadow-md border flex flex-col h-full ${cardClasses}`}>
  <div class="flex justify-between items-start mb-2">
    <h3 class="font-bold text-lg text-slate-800">{title}</h3>
    
    <span class={`px-2 py-0.5 rounded-full text-xs font-semibold ${badgeClasses}`}>
      {status === 'lost' ? 'Verloren' : 'Gefunden'}
    </span>
  </div>

  <!-- Zeigt die Kategorie nur an, wenn sie auch einen Wert hat -->
  {category && <p class="text-sm text-slate-600 mb-4">{category}</p>}
  
  <div class="mt-auto space-y-2 text-sm text-slate-700">
    <!-- Zeigt den Ort nur an, wenn er einen Wert hat -->
    {location && (
      <div class="flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
        <span>{location}</span>
      </div>
    )}
    <div class="flex items-center">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
      <span>{date}</span>
    </div>
  </div>

  <a href={`/items/${id}`} class="mt-4 text-blue-600 hover:underline font-semibold text-sm">
    Mehr lesen &rarr;
  </a>
</div>

</./components/itemCard.astro>
<./components/footer.astro>
---
// src/components/Footer.astro
const today = new Date();
---

<footer class="mt-auto w-full pt-10 pb-4">
  <div class="border-t border-slate-200">
    <div class="mx-auto max-w-screen-lg px-4 pt-8">
      <div class="grid grid-cols-1 gap-8 md:grid-cols-3">
        
        <!-- Sektion: Hauptnavigation -->
        <div>
          <h3 class="text-lg font-semibold text-slate-800">Navigation</h3>
          <ul class="mt-4 space-y-2">
            <li><a href="/" class="text-slate-600 hover:text-blue-600 hover:underline">Startseite</a></li>
            <li><a href="/objekte" class="text-slate-600 hover:text-blue-600 hover:underline">Objekte suchen</a></li>
            <li><a href="/melden" class="text-slate-600 hover:text-blue-600 hover:underline">Etwas melden</a></li>
            <li><a href="/kontakt" class="text-slate-600 hover:text-blue-600 hover:underline">Kontakt</a></li>
          </ul>
        </div>

        <!-- Sektion: Rechtliches -->
        <div>
          <h3 class="text-lg font-semibold text-slate-800">Rechtliches</h3>
          <ul class="mt-4 space-y-2">
            <li><a href="/impressum" class="text-slate-600 hover:text-blue-600 hover:underline">Impressum</a></li>
            <li><a href="/datenschutz" class="text-slate-600 hover:text-blue-600 hover:underline">Datenschutzerklärung</a></li>
          </ul>
        </div>

        <!-- Sektion: Über das Projekt -->
        <div>
          <h3 class="text-lg font-semibold text-slate-800">Lost and Found Web</h3>
          <p class="mt-4 text-slate-600">
            Unsere Plattform hilft Ihnen, verlorene Gegenstände wiederzufinden oder Finder zu kontaktieren.
          </p>
        </div>

      </div>

      <!-- Copyright-Zeile am Ende -->
      <div class="mt-10 border-t border-slate-200 pt-6">
        <p class="text-center text-sm text-slate-500">
          Copyright © {today.getFullYear()} Lost and Found Web. Alle Rechte vorbehalten.
        </p>
      </div>

    </div>
  </div>
</footer>

</./components/footer.astro>
<./components/navbar.astro>
 <!-- Navbar für SPA -->
 <nav class="bg-white w-full relative z-10">
    <div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
  
    <!-- Logo links - JETZT ALS LINK ZUR STARTSEITE -->
      <!-- Das <a>-Tag um das div macht den gesamten Bereich klickbar -->
      <!-- href="/" leitet zur Homepage (src/pages/index.astro) -->
      <a href="/" class="text-xl font-bold text-blue-600 hover:text-blue-700">
        Lost and Found
      </a>
  
  
      <!-- Burger-Menü für Mobil -->
      <input id="nav-toggle" type="checkbox" class="peer hidden" />
      <label for="nav-toggle" class="cursor-pointer md:hidden">
        <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
      </label>
  
      <!-- Navigation + Login rechts -->
      <div class="hidden peer-checked:flex absolute top-full left-0 w-full flex-col gap-4 bg-white px-4 py-4
                  md:flex md:static md:flex-row md:items-center md:gap-6 md:ml-auto md:w-auto">
  
        <!-- Navigation rechts -->
        <ul class="flex flex-col md:flex-row md:gap-6 md:items-center md:ml-auto">
          <li><a href="/items/" class="text-xl text-gray-700 hover:text-blue-600">Items</a></li>
          <li><a href="/report/" class="text-xl text-gray-700 hover:text-blue-600">Report</a></li>
          <li><a href="/aboutus/" class="text-xl text-gray-700 hover:text-blue-600">About Us</a></li>
        </ul>
  
        <!-- Login-Button ganz rechts -->
        <a href="/login/"
           class="text-xl border border-blue-600 text-blue-600 rounded px-4 py-2 hover:bg-blue-600 hover:text-white transition md:ml-6">
          Login
        </a>
      </div>
  
    </div>
  </nav>
  
</./components/navbar.astro>
<./layouts/Layout.astro>
---
//import { SEO } from "../components/SEO.astro";

import Navbar from "../components/navbar.astro";
import Footer from "../components/footer.astro";

// Import des globalen Tailwind-Stylesheets
import '../styles/global.css'; 

export interface Props {
  title: string;
  active?: string; // `active` ist optional, da nicht jede Seite es braucht
}

// Stelle sicher, dass Astro.site und Astro.url verfügbar sind (Standard in Astro)
const canonicalURL = new URL(Astro.url.pathname, Astro.site).toString();
const resolvedImageWithDomain = new URL(
  "/opengraph.jpg",
  Astro.site
).toString();

const { title, active } = Astro.props; // `active` hier dekonstruieren

// Ändere dies, um nur den übergebenen Titel zu verwenden oder deine eigene Logik
const makeTitle = title
  ? title // Wenn ein Titel übergeben wurde, nimm diesen
  : "Lost and Found Web - Deine Webseite für Verlorenes und Gefundenes"; // Sonst den Standard

const theme = "light";
---

<!DOCTYPE html>
<html lang="de" data-theme={theme}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    
    <title>{makeTitle}</title>

    </head>
  <body class="h-full">
  <div class="w-full flex flex-col min-h-screen">
      
      <Navbar active={active}/> 
      
      <div class="mx-auto max-w-screen-lg px-4 flex flex-col flex-grow"></div>

      <main class="flex-grow">
        <slot />
      </main>
      
      <Footer />
      
      <style is:global>
      /* Improve Page speed */
      /* https://css-tricks.com/almanac/properties/c/content-visibility/ */
      img {
        content-visibility: auto;
      }
      </style>
    </div>
  </div>
</body>
</html>
</./layouts/Layout.astro>
<./pages/index.astro>
---
// Importiere DEIN Layout, das in src/layouts/Layout.astro gespeichert ist
import Layout from "../layouts/Layout.astro";
import ItemCard from '../components/itemCard.astro';
---

<Layout title="Willkommen beim Lost and Found Web" active="home">
    <div class="mx-auto max-w-screen-lg px-4">
        <h1 class="text-5xl font-extrabold text-blue-800 my-5 text-center">Willkommen beim Lost and Found Web!</h1>
        <p class="text-xl py-5 text-center">
            Hier finden Sie verlorene Gegenstände und können gefundene Gegenstände melden.
            Unsere Plattform hilft Ihnen, Vermisstes wiederzufinden oder einen Finder zu kontaktieren.
        </p>
        <div class="text-center mt-8">
            <a href="/items" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-4">
                Objekte suchen
            </a>
            <a href="/melden" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
                Etwas melden
            </a>
        </div>
    </div>
</Layout>
</./pages/index.astro>
<./pages/aboutus.astro>
---
import Layout from '../layouts/Layout.astro';
---
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=search" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=mood" />

<Layout title="Was ist Lost and Found?">
    <div class="container mx-auto px-4 py-8">

        <main class="text-center py-16">
            <h1 class="text-6xl font-bold mb-4">Was ist <span class="text-primary">Lost and Found</span>?</h1>
            <p class="text-2xl text-base-content/70 mb-12">Euer digitales Fundbüro an der Uni!</p>

            <div class="max-w-4xl mx-auto text-lg text-base-content leading-relaxed space-y-6">
                <p>
                    Kennst du das? Du hetzt durch den Unialltag, von der Vorlesung zur Mensa, und plötzlich
                    fällst du aus allen Wolken: Dein Schlüssel fehlt. Die Sporttasche ist weg. Oder die Jacke?
                    Nervig, oder? Genau dafür gibt es jetzt CampusFind - dein digitales Fundbüro, das den Uni-
                    Alltag ein kleines bisschen entspannter macht.
                </p>
                <p>
                    CampusFind ist deine zentrale Anlaufstelle, wenn auf dem Campus etwas
                    abhandengekommen ist oder jemand anderes etwas wieder gefunden hat, was du
                    zurückgeben möchtest. Schluss mit Zettelwirtschaft am Schwarzen Brett oder der Suche in
                    zig verschiedenen Büros!
                </p>
            </div>
        </main>

        <section class="py-20">
            <h2 class="text-3xl font-bold text-slate-900 mb-8">So einfach funktioniert CampusFind:</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8 text-center">
                <div class="card bg-base-100 shadow-xl p-8 items-center text-center">
                    <div class="text-7xl text-primary mb-6">⁇</div>
                    <div class="card-body p-0">
                        <h3 class="card-title justify-center text-2xl mb-2">Verloren oder gefunden?</h3>
                        <p class="text-base-content/80">
                            erstelle in wenigen Schritten einen Eintrag, damit andere sehen, dass du etwas verloren/gefunden hast
                        </p>
                    </div>
                </div>

                <div class="card bg-base-100 shadow-xl p-8 items-center text-center">
                    <div class="text-7xl text-primary mb-6">
                        <span class="material-symbols-outlined">
                            search
                        </span>
                    </div>
                    <div class="card-body p-0">
                        <h3 class="card-title justify-center text-2xl mb-2">Schnell finden durch Filter</h3>
                        <p class="text-base-content/80">
                            Filter, wie Datum oder Ort, helfen dir dabei, das, was du Verlorenes noch schneller finden kannst
                        </p>
                    </div>
                </div>

                <div class="card bg-base-100 shadow-xl p-8 items-center text-center">
                    <div class="text-7xl text-primary mb-6">
                        <span class="material-symbols-outlined">
                            mood
                        </span>
                    </div>
                    <div class="card-body p-0">
                        <h3 class="card-title justify-center text-2xl mb-2">Zurück zum Besitzer</h3>
                        <p class="text-base-content/80">
                            Verlorenes gelangt ganz einfach und unkompliziert zu seinem Besitzer
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <footer class="text-center py-16 text-base-content/80">
            <p class="mb-4 font-semibold">
                Weniger Stress, mehr Happy End!
            </p>
            <p class="max-w-3xl mx-auto">
                Wir wissen, wie ärgerlich es sein kann, etwas zu verlieren. Deshalb ist es unser Ziel, dir mit CampusFind
                eine Plattform zu bieten, die den Suchprozess nicht nur einfacher, sondern auch stressfreier macht. So
                wird unser Campus nicht nur digitaler, sondern auch noch hilfsbereiter und entspannter.
            </p>
        </footer>
    </div>
</Layout>
</./pages/aboutus.astro>
<./pages/report.astro>
---
import Layout from "../layouts/Layout.astro";

// Importiere die SQLite-Bibliothek und den Pfad, um auf die Datenbank zuzugreifen
import sqlite from 'better-sqlite3';
import * as path from 'path';

// Der Pfad zur Datenbankdatei. Stellen Sie sicher, dass dies korrekt ist.
// Wenn Ihre database.db im Ordner 'database' liegt, sollte der Pfad so aussehen:
const dbPath = path.resolve("./src/database/database.db"); 
// Wenn database.db direkt im Projekt-Root liegt, dann: const dbPath = path.resolve("./database.db");

// Variablen für Kategorien und Standorte initialisieren
let categories = [];
let locations = [];

// Datenbankabfrage im Server-Side Render (SSR) oder Build-Prozess von Astro
// Dieser Code wird auf dem Server ausgeführt, NICHT im Browser
try {
  const db = new sqlite(dbPath, { readonly: true }); // Datenbank nur zum Lesen öffnen
  // Kategorien aus der 'categories'-Tabelle abrufen
  categories = db.prepare('SELECT id, name FROM categories ORDER BY name ASC').all();
  // Standorte aus der 'locations'-Tabelle abrufen
  locations = db.prepare('SELECT id, name FROM locations ORDER BY name ASC').all();
  db.close(); // Datenbankverbindung schließen
} catch (error) {
  console.error("Fehler beim Laden der Kategorien oder Standorte aus der Datenbank:", error);
  // Hier könnten Sie auch eine Fallback-Nachricht oder leere Optionen anzeigen
  // oder den Fehler auf der Seite sichtbar machen.
}

// Client-seitiges Skript für die Formularverarbeitung
// Dieses Skript wird im Browser ausgeführt
const script = `
  document.addEventListener('DOMContentLoaded', () => {
    const reportForm = document.getElementById('reportForm');
    const messageDiv = document.getElementById('message');

    if (reportForm) {
      reportForm.addEventListener('submit', async (event) => {
        event.preventDefault(); // Verhindert das Standard-Formular-Submit

        messageDiv.textContent = ''; // Alte Nachrichten löschen
        messageDiv.className = 'p-3 rounded-md text-center'; // Reset classes

        const formData = new FormData(reportForm);
        const itemData = {};
        for (const [key, value] of formData.entries()) {
          itemData[key] = value;
        }
        itemData.title = itemData.name;

        // Konvertiere die Datumseingabe in einen Unix-Timestamp (Sekunden seit 1970)
        if (itemData.date) {
            itemData.date = new Date(itemData.date).getTime() / 1000;
        } else {
            itemData.date = null; // Wenn kein Datum eingegeben wurde
        }
        itemData.reportedAt = Math.floor(Date.now() / 1000); // Aktueller Unix-Timestamp

        // Die tatsächlichen IDs aus den Dropdowns verwenden
        // itemData.category und itemData.location enthalten jetzt die ID-Werte der ausgewählten Optionen
        itemData.categoryId = itemData.category; 
        itemData.locationId = itemData.location; 
        
        // Dummy-Wert für userId, da dieser aus der Authentifizierung kommen müsste
        // In einer echten Anwendung würden Sie hier die ID des eingeloggten Benutzers verwenden.
        itemData.userId = 'dummy-user-id-123'; 

        // Entferne die temporären Felder 'category' und 'location', da wir categoryId und locationId verwenden
        delete itemData.category;
        delete itemData.location;

        // Bild-Upload: falls Datei ausgewählt, nur Dateiname übernehmen, sonst null
        const imgFile = formData.get('img');
        itemData.img = (imgFile && imgFile.name) ? imgFile.name : null;

        console.log('Sende Daten:', itemData);

        try {
          // Annahme: Ihre POST-API-Route ist unter /api/items erreichbar
          const response = await fetch('/api/items', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(itemData),
          });

          const result = await response.json();

          if (response.ok && result.success === 'ok') {
            messageDiv.textContent = 'Gegenstand erfolgreich gemeldet!';
            messageDiv.classList.add('bg-green-100', 'text-green-800');
            reportForm.reset(); // Formular zurücksetzen
          } else {
            messageDiv.textContent = 'Fehler beim Melden des Gegenstands: ' + (result.message || 'Unbekannter Fehler');
            messageDiv.classList.add('bg-red-100', 'text-red-800');
          }
        } catch (error) {
          console.error('Fetch-Fehler:', error);
          messageDiv.textContent = 'Netzwerkfehler oder Server nicht erreichbar.';
          messageDiv.classList.add('bg-red-100', 'text-red-800');
        }
      });
    }
  });
`;
---

<Layout title="Gegenstand melden" active="report">
  <div class="mx-auto max-w-screen-lg px-4">
    <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Melden Sie einen verlorenen oder gefundenen Gegenstand.</h1>

    <form id="reportForm" class="space-y-6">
      <!-- Is the item lost or found? -->
      <div>
        <label class="block text-gray-700 text-lg font-semibold mb-2">Ist der Gegenstand verloren oder gefunden? <span class="text-red-500">*</span></label>
        <div class="flex items-center space-x-6">
          <label class="inline-flex items-center">
            <input type="radio" name="type" value="isLost" class="form-radio h-5 w-5 text-blue-600 rounded-full" required>
            <span class="ml-2 text-gray-700 text-base">Verloren</span>
          </label>
          <label class="inline-flex items-center">
            <input type="radio" name="type" value="isFound" class="form-radio h-5 w-5 text-blue-600 rounded-full" required>
            <span class="ml-2 text-gray-700 text-base">Gefunden</span>
          </label>
        </div>
      </div>

      <!-- Item name -->
      <div>
        <label for="name" class="block text-gray-700 text-lg font-semibold mb-2">Gegenstandsname <span class="text-red-500">*</span></label>
        <input type="text" id="name" name="name" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-base" placeholder="Name des Gegenstands" required>
      </div>

      <!-- Category Dropdown (JETZT DYNAMISCH BEFÜLLT) -->
      <div>
        <label for="category" class="block text-gray-700 text-lg font-semibold mb-2">Kategorie <span class="text-red-500">*</span></label>
        <select id="category" name="category" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-base" required>
            <option value="">Wählen Sie eine Kategorie</option>
            {categories.map(category => (
              <option value={category.id}>{category.name}</option>
            ))}
        </select>
      </div>

      <!-- Location Dropdown (JETZT DYNAMISCH BEFÜLLT) -->
      <div>
        <label for="location" class="block text-gray-700 text-lg font-semibold mb-2">Ort <span class="text-red-500">*</span></label>
        <select id="location" name="location" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-base" required>
            <option value="">Wählen Sie einen Ort</option>
            {locations.map(location => (
              <option value={location.id}>{location.name}</option>
            ))}
        </select>
      </div>

      <!-- Date Lost/Found -->
      <div>
        <label for="date" class="block text-gray-700 text-lg font-semibold mb-2">Datum verloren/gefunden</label>
        <input type="date" id="date" name="date" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-base">
      </div>

      <!-- Description -->
      <div>
        <label for="description" class="block text-gray-700 text-lg font-semibold mb-2">Beschreibung</label>
        <textarea id="description" name="description" rows="4" class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-base" placeholder="Geben Sie Details wie Farbe, Marke, besondere Merkmale usw. an."></textarea>
      </div>

      <!-- Image-Upload -->
      <div>
        <label for="img" class="block text-gray-700 text-lg font-semibold mb-2">Bild hochladen</label>
        <input type="file" id="img" name="img" accept="image/*" class="w-full text-base" />
      </div>

      <!-- Message Area for Feedback -->
      <div id="message" class="hidden"></div>

      <!-- Submit Button -->
      <div class="text-center">
        <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out shadow-md">
          Bericht absenden
        </button>
      </div>
    </form>
  </div>

  <script is:inline>
    {script}
  </script>
</Layout>

</./pages/report.astro>
<./pages/items.astro>
---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Objekte suchen - Lost and Found Web" active="objekte">
    <div class="mx-auto max-w-screen-lg px-4">
        <h1>Verlorene Objekte suchen</h1>
        <p>Hier können Sie nach verlorenen Gegenständen suchen.</p>
    </div>
</Layout>
</./pages/items.astro>
<./pages/api/locations.ts>
// src/pages/api/locations.ts
import type { APIRoute } from 'astro';
import sqlite from 'better-sqlite3';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import dayjs from 'dayjs';

// Wichtig: Der dbPath muss dem Pfad in deiner initdb.js entsprechen!
// Da deine initdb.js die Datei im Projekt-Root ablegt, muss dieser Pfad korrekt sein.
const dbPath = path.resolve("./database.db"); // Angepasst an deinen initdb.js Pfad

export const GET: APIRoute = async () => {
  let db = new sqlite(dbPath);
  let locationsFromDb = await db.prepare('SELECT id, name FROM Locations').all();
  db.close();
  return new Response(JSON.stringify(
      {
        locations: locationsFromDb,
        success: "ok",
        message: ""
      }), {
        status: 200,
      });
};

export const POST: APIRoute = async ({ request }) => {
  let location = await request.json();
  if (location.hasOwnProperty("name")) {
      let id = uuidv4();
      let now = dayjs().unix();
      let db = new sqlite(dbPath);
      let added = db.prepare("INSERT INTO Locations (id, name, createdAt, updatedAt) VALUES (?,?,?,?)")
                    .run(id, location.name, now, now);
      db.close();
      return new Response(JSON.stringify({
          locations: added,
          success: "ok",
          message: "location added"
        }),
        {
          status : 200
        });
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "attributes missing (name required)"
        }),{
          status : 400
        });
    }
};

export const PUT: APIRoute = async ({ request }) => {
  let location = await request.json();
  if (location.hasOwnProperty("id") && location.hasOwnProperty("name")) {
      let now = dayjs().unix();
      let db = new sqlite(dbPath);
      const updates = db.prepare('UPDATE Locations SET name = ?, updatedAt = ? WHERE id = ?')
                     .run(location.name, now, location.id);
      db.close();
      return new Response(JSON.stringify({
          locations: updates,
          success: "ok",
          message: "location updated"
        }),{
          status : 200
        });
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "attributes missing (id, name required)"
        }),{
          status : 400
        });
    }
};

export const DELETE: APIRoute = async ({ request }) => {
  const url = new URL(request.url);
  const id = url.searchParams.get('id');
  if (id !== null) {
      let db = new sqlite(dbPath);
      const deleted = db.prepare('DELETE FROM Locations WHERE id = ?').run(id);
      db.close();
      return new Response(JSON.stringify({
        locationObject: {
          locations: deleted,
          success: "ok",
          message: "location deleted"
        }
      }))
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "id parameter missing"
        }),{
          status : 400
        });
    }
};
</./pages/api/locations.ts>
<./pages/api/items.ts>
// src/pages/api/items.ts
import type { APIRoute } from 'astro';
import sqlite from 'better-sqlite3';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import dayjs from 'dayjs';

// Wichtig: Der dbPath muss dem Pfad in deiner initdb.js entsprechen!
// Da deine initdb.js die Datei im Projekt-Root ablegt, muss dieser Pfad korrekt sein.
const dbPath = path.resolve("./src/database/database.db"); // Angepasst an deinen initdb.js Pfad

export const GET: APIRoute = async () => {
  let db = new sqlite(dbPath);
  let itemsFromDb = await db.prepare('SELECT id, name, img, type, title, date, reportedAt, categoryId, description, locationId, userId FROM Items').all();
  db.close();
  return new Response(JSON.stringify(
      {
        items: itemsFromDb,
        success: "ok",
        message: ""
      }), {
        status: 200,
      });
};

export const POST: APIRoute = async ({ request }) => {
  let item = await request.json();
  // Prüfe, ob alle notwendigen (NOT NULL) Felder vorhanden sind
  if (item.hasOwnProperty("name") && item.hasOwnProperty("type") && item.hasOwnProperty("title") && item.hasOwnProperty("reportedAt") && item.hasOwnProperty("categoryId") && item.hasOwnProperty("locationId") && item.hasOwnProperty("userId")) {
      let id = uuidv4();
      let now = dayjs().unix();
      let db = new sqlite(dbPath);
      let added = db.prepare("INSERT INTO Items (id, name, img, type, title, date, reportedAt, categoryId, description, locationId, userId, createdAt, updatedAt) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)")
                    .run(
                        id,
                        item.name,
                        item.img || null, // img ist optional, setze auf null wenn nicht im Request
                        item.type,
                        item.title,
                        item.date || null, // date ist optional, setze auf null wenn nicht im Request
                        item.reportedAt,
                        item.categoryId,
                        item.description || null, // description ist optional
                        item.locationId,
                        item.userId,
                        now,
                        now
                    );
      db.close();
      return new Response(JSON.stringify({
          items: added,
          success: "ok",
          message: "item added"
        }),
        {
          status : 200
        });
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "attributes missing (name, type, title, reportedAt, categoryId, locationId, userId required)"
        }),{
          status : 400
        });
    }
};

export const PUT: APIRoute = async ({ request }) => {
  let item = await request.json();
  // Prüfe, ob alle notwendigen Felder (inkl. id zum Updaten) vorhanden sind
  if (item.hasOwnProperty("id") && item.hasOwnProperty("name") && item.hasOwnProperty("type") && item.hasOwnProperty("title") && item.hasOwnProperty("reportedAt") && item.hasOwnProperty("categoryId") && item.hasOwnProperty("locationId") && item.hasOwnProperty("userId")) {
      let now = dayjs().unix();
      let db = new sqlite(dbPath);
      const updates = db.prepare('UPDATE Items SET name = ?, img = ?, type = ?, title = ?, date = ?, reportedAt = ?, categoryId = ?, description = ?, locationId = ?, userId = ?, updatedAt = ? WHERE id = ?')
                     .run(
                        item.name,
                        item.img || null,
                        item.type,
                        item.title,
                        item.date || null,
                        item.reportedAt,
                        item.categoryId,
                        item.description || null,
                        item.locationId,
                        item.userId,
                        now,
                        item.id
                    );
      db.close();
      return new Response(JSON.stringify({
          items: updates,
          success: "ok",
          message: "item updated"
        }),{
          status : 200
        });
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "attributes missing (id, name, type, title, reportedAt, categoryId, locationId, userId required)"
        }),{
          status : 400
        });
    }
};

export const DELETE: APIRoute = async ({ request }) => {
  const url = new URL(request.url);
  const id = url.searchParams.get('id');
  if (id !== null) {
      let db = new sqlite(dbPath);
      const deleted = db.prepare('DELETE FROM Items WHERE id = ?').run(id);
      db.close();
      return new Response(JSON.stringify({
        itemObject: {
          items: deleted,
          success: "ok",
          message: "item deleted"
        }
      }));
    } else {
      return new Response(
        JSON.stringify({
            success: "error",
            message: "id parameter missing"
        }),{
          status : 400
        });
    }
};
</./pages/api/items.ts>
<./pages/api/userdb.ts>
import type { APIRoute } from 'astro';
import sqlite from 'better-sqlite3';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import dayjs from 'dayjs';


const dbPath = path.resolve("./src/database/", 'database.db');
console.log(dbPath);

export const GET: APIRoute = async ({ params, request }) => {
  let db = new sqlite(dbPath);
  let usersFromDb = await db.prepare('SELECT id, prename, surname, username, password, phone, email FROM Users').all();
  console.log("usersFromDb", usersFromDb);
  db.close();
  // da dies quasi immer klappt, brauchen wir keinen Fehler zurück geben.
  // Es wird ein Objekt zurück gegeben, dass  
  return new Response(JSON.stringify(
      {
        users: usersFromDb, 
        success: "ok",
        message: ""
      }), {
        // wir zeigen damit an, dass die Anfrage fehlerfrei war. 
        status: 200,
      })
}

export const POST: APIRoute = async ({ params, request }) => {
  // request.json ist eine Funktion, die Astro bereitstellt. 
  // Die Daten im Body (JSON-String) werden in ein JS-Objekt umgewandelt.
  let user = await request.json();
  console.log("user", user);
  if ( user.hasOwnProperty("prename")
    && user.hasOwnProperty("surname")
    && user.hasOwnProperty("username")
    && user.hasOwnProperty("password")
    && user.hasOwnProperty("phone")
    && user.hasOwnProperty("email")) {
      // Der neue Datensatz hat noch keinen Primärschlüssel, diesen erzeugen wir 
      // als UUID. Diese sind viel sicherer als Integerzahlen, die bei jedem Eintrag erhöht werden
      // da Hacker es viel schwerer haben, die UUID zu erraten. 
      let id = uuidv4();
      let now = dayjs().unix(); 
      let db = new sqlite(dbPath);
      
      let added = db.prepare("INSERT INTO Users (id, prename, surname, username, password, phone, email, createdAt, updatedAt) VALUES (?,?,?,?,?,?,?,?,?)")
                    .run(id, user.prename, user.surname, user.username, user.password, user.phone, user.email, now, now);
      db.close();
      return new Response(JSON.stringify({
          // der hinzugefügte Datensatz wird noch mitgeschickt. 
          users: added, 
          success: "ok",
          message: "user added"
        }),         
        {
          // Hat geklappt. 
          status : 200
        })
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Ein Attribut hat gefehlt. Darum Fehlercode 400
          status : 400
        })
    }
}

export const PUT: APIRoute = async ({ params, request }) => {
  // überprüfen, ob alle Daten vorhanden sind. 
  // Die Daten werden in dem Body übertragen. 
  // Diese Daten im Body lassen sich durch umwandeln 
  // des JSON Strings 
  let user = await request.json();
  console.log(user)
  if ( user.hasOwnProperty("id")
    && user.hasOwnProperty("prename")
    && user.hasOwnProperty("surname")
    && user.hasOwnProperty("username")
    && user.hasOwnProperty("password")
    && user.hasOwnProperty("phone")
    && user.hasOwnProperty("email")) {
      let now = dayjs().unix(); 
      let db = new sqlite(dbPath);
      const updates = db.prepare('UPDATE Users SET prename = ?, surname = ?, username = ?, password = ?, phone = ?, email = ?, updatedAt = ? WHERE id = ?')
                     .run(user.prename, user.surname, user.username, user.password, user.phone, user.email, now, user.id); 
      db.close();
      return new Response(JSON.stringify({
          // der hinzugefügte Datensatz wird noch mitgeschickt. 
          users: updates, 
          success: "ok",
          errorMessage: "user updated"
        }),{
          // Hat funktioniert -> Status 200 
          status : 200
        })
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Fehler-Fall gibt Status 400 zurück. 
          status : 400
        })
    }
}

export const DELETE: APIRoute = async ({ request }) => {
  // überprüfen, ob alle Daten vorhanden sind. 
  // Die ID wird hier im Header übertragen.
  const url = new URL(request.url);
  const id = url.searchParams.get('id');
  // Falls der Parameter id nicht vorhanden ist, wird null zurück gegeben. 
  if (id !== null) {
      let db = new sqlite(dbPath);
      // Die Zeile mit der ID löschen mit DELETE
      const deleted = db.prepare('DELETE FROM Users WHERE id = ?').run(id);
      db.close();
      return new Response(JSON.stringify({
        userObject: {
          users: deleted, 
          success: "ok",
          message: "user deleted"
        }
      }))
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Fehler-Fall gibt Status 400 zurück. 
          status : 400
        })
    }
}


</./pages/api/userdb.ts>
<./pages/api/categorydb.ts>
import type { APIRoute } from 'astro';
import sqlite from 'better-sqlite3';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';
import dayjs from 'dayjs';


const dbPath = path.resolve("./src/database/", 'database.db');
console.log(dbPath);

export const GET: APIRoute = async ({ params, request }) => {
  let db = new sqlite(dbPath);
  let categoriesFromDb = await db.prepare('SELECT id, name FROM Categories').all();
  console.log("categorysFromDb", categoriesFromDb);
  db.close();
  // da dies quasi immer klappt, brauchen wir keinen Fehler zurück geben.
  // Es wird ein Objekt zurück gegeben, dass  
  return new Response(JSON.stringify(
      {
        categories: categoriesFromDb, 
        success: "ok",
        message: ""
      }), {
        // wir zeigen damit an, dass die Anfrage fehlerfrei war. 
        status: 200,
      })
}

export const POST: APIRoute = async ({ params, request }) => {
  // request.json ist eine Funktion, die Astro bereitstellt. 
  // Die Daten im Body (JSON-String) werden in ein JS-Objekt umgewandelt.
  let category = await request.json();
  console.log("category", category);
  if ( category.hasOwnProperty("name")) {
      // Der neue Datensatz hat noch keinen Primärschlüssel, diesen erzeugen wir 
      // als UUID. Diese sind viel sicherer als Integerzahlen, die bei jedem Eintrag erhöht werden
      // da Hacker es viel schwerer haben, die UUID zu erraten. 
      let id = uuidv4();
      let now = dayjs().unix(); 
      let db = new sqlite(dbPath);
      
      let added = db.prepare("INSERT INTO Categories (id, name, createdAt, updatedAt) VALUES (?,?,?,?)")
                    .run(id, category.name, now, now);
      db.close();
      return new Response(JSON.stringify({
          // der hinzugefügte Datensatz wird noch mitgeschickt. 
          categories: added, 
          success: "ok",
          message: "category added"
        }),         
        {
          // Hat geklappt. 
          status : 200
        })
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Ein Attribut hat gefehlt. Darum Fehlercode 400
          status : 400
        })
    }
}

export const PUT: APIRoute = async ({ params, request }) => {
  // überprüfen, ob alle Daten vorhanden sind. 
  // Die Daten werden in dem Body übertragen. 
  // Diese Daten im Body lassen sich durch umwandeln 
  // des JSON Strings 
  let category = await request.json();
  console.log(category)
  if ( category.hasOwnProperty("id")
    && category.hasOwnProperty("name")) {
      let now = dayjs().unix(); 
      let db = new sqlite(dbPath);
      const updates = db.prepare('UPDATE Categories SET name = ?, updatedAt = ? WHERE id = ?')
                     .run(category.name, now, category.id); 
      db.close();
      return new Response(JSON.stringify({
          // der hinzugefügte Datensatz wird noch mitgeschickt. 
          categories: updates, 
          success: "ok",
          errorMessage: "category updated"
        }),{
          // Hat funktioniert -> Status 200 
          status : 200
        })
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Fehler-Fall gibt Status 400 zurück. 
          status : 400
        })
    }
}

export const DELETE: APIRoute = async ({ request }) => {
  // überprüfen, ob alle Daten vorhanden sind. 
  // Die ID wird hier im Header übertragen.
  const url = new URL(request.url);
  const id = url.searchParams.get('id');
  // Falls der Parameter id nicht vorhanden ist, wird null zurück gegeben. 
  if (id !== null) {
      let db = new sqlite(dbPath);
      // Die Zeile mit der ID löschen mit DELETE
      const deleted = db.prepare('DELETE FROM Categories WHERE id = ?').run(id);
      db.close();
      return new Response(JSON.stringify({
        categoryObject: {
          categories: deleted, 
          success: "ok",
          message: "category deleted"
        }
      }))
    } else {
      return new Response(
        JSON.stringify({   
            success: "error",
            message: "attributes missing"
        }),{
          // Fehler-Fall gibt Status 400 zurück. 
          status : 400
        })
    }
}


</./pages/api/categorydb.ts>
